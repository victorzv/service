<?php
/**
 * ApiApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Aspose.Pdf RestApi
 *
 * Aspose.Pdf RestApi provides a comprehensive set of endpoints for various PDF-related tasks, enabling efficient document processing and manipulation. Users can retrieve processing status, download files, manage file locks, parse documents, redact sensitive information, convert between formats, merge files, add watermarks, perform text searches, and much more. With endpoints for tasks like electronic signing, document comparison, and form filling, the API offers extensive functionality to cater to diverse PDF requirements.
 *
 * OpenAPI spec version: v1
 * Contact: Evgeny.Pirogov@aspose.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Stream;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ApiApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ApiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pdfWebapiAddnumberPost
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiAddnumberPost($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        list($response) = $this->pdfWebapiAddnumberPostWithHttpInfo($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);
        return $response;
    }

    /**
     * Operation pdfWebapiAddnumberPostWithHttpInfo
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiAddnumberPostWithHttpInfo($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiAddnumberPostAsync
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsync($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        return $this->pdfWebapiAddnumberPostAsyncWithHttpInfo($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiAddnumberPostAsyncWithHttpInfo
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsyncWithHttpInfo($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiAddnumberPost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiAddnumberPostRequest($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/addnumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($v_alignment !== null) {
            $queryParams['vAlignment'] = ObjectSerializer::toQueryValue($v_alignment, null);
        }
        // query params
        if ($h_alignment !== null) {
            $queryParams['hAlignment'] = ObjectSerializer::toQueryValue($h_alignment, null);
        }
        // query params
        if ($starting_number !== null) {
            $queryParams['startingNumber'] = ObjectSerializer::toQueryValue($starting_number, 'int32');
        }
        // query params
        if ($s_number !== null) {
            $queryParams['sNumber'] = ObjectSerializer::toQueryValue($s_number, 'int32');
        }
        // query params
        if ($f_number !== null) {
            $queryParams['fNumber'] = ObjectSerializer::toQueryValue($f_number, 'int32');
        }
        // query params
        if ($margin !== null) {
            $queryParams['margin'] = ObjectSerializer::toQueryValue($margin, 'int32');
        }
        // query params
        if ($font_size !== null) {
            $queryParams['fontSize'] = ObjectSerializer::toQueryValue($font_size, 'int32');
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiChangeFontsPost
     *
     * @param  string $font_replacements_json font_replacements_json (optional)
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiChangeFontsPost($font_replacements_json = null, $files = null)
    {
        list($response) = $this->pdfWebapiChangeFontsPostWithHttpInfo($font_replacements_json, $files);
        return $response;
    }

    /**
     * Operation pdfWebapiChangeFontsPostWithHttpInfo
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiChangeFontsPostWithHttpInfo($font_replacements_json = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChangeFontsPostRequest($font_replacements_json, $files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiChangeFontsPostAsync
     *
     * 
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChangeFontsPostAsync($font_replacements_json = null, $files = null)
    {
        return $this->pdfWebapiChangeFontsPostAsyncWithHttpInfo($font_replacements_json, $files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiChangeFontsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChangeFontsPostAsyncWithHttpInfo($font_replacements_json = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChangeFontsPostRequest($font_replacements_json, $files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiChangeFontsPost'
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiChangeFontsPostRequest($font_replacements_json = null, $files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/change-fonts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($font_replacements_json !== null) {
            $formParams['fontReplacementsJson'] = ObjectSerializer::toFormValue($font_replacements_json);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiComparisonPost
     *
     * Compare documents text.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiComparisonPost($files = null)
    {
        list($response) = $this->pdfWebapiComparisonPostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiComparisonPostWithHttpInfo
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiComparisonPostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiComparisonPostAsync
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsync($files = null)
    {
        return $this->pdfWebapiComparisonPostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiComparisonPostAsyncWithHttpInfo
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiComparisonPost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiComparisonPostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Comparison';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCompressPost
     *
     * Compress document.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCompressPost($files = null, $compress_type = null)
    {
        list($response) = $this->pdfWebapiCompressPostWithHttpInfo($files, $compress_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCompressPostWithHttpInfo
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCompressPostWithHttpInfo($files = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $compress_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();

            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCompressPostAsync
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsync($files = null, $compress_type = null)
    {
        return $this->pdfWebapiCompressPostAsyncWithHttpInfo($files, $compress_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCompressPostAsyncWithHttpInfo
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsyncWithHttpInfo($files = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $compress_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCompressPost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCompressPostRequest($files = null, $compress_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_type !== null) {
            $queryParams['compressType'] = ObjectSerializer::toQueryValue($compress_type, null);
        }

        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }

        // body params
        $_tempBody = null;


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request =  new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
        return $request;
    }

    /**
     * Operation pdfWebapiConvertPost
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertPost($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        list($response) = $this->pdfWebapiConvertPostWithHttpInfo($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertPostWithHttpInfo
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertPostWithHttpInfo($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertPostAsync
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsync($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        return $this->pdfWebapiConvertPostAsyncWithHttpInfo($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertPostAsyncWithHttpInfo
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertPostRequest($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($xml_type !== null) {
            $queryParams['xmlType'] = ObjectSerializer::toQueryValue($xml_type, null);
        }
        // query params
        if ($xml_tag !== null) {
            $queryParams['xmlTag'] = ObjectSerializer::toQueryValue($xml_tag, null);
        }
        // query params
        if ($font_sise !== null) {
            $queryParams['fontSise'] = ObjectSerializer::toQueryValue($font_sise, 'int32');
        }
        // query params
        if ($is_to_single !== null) {
            $queryParams['isToSingle'] = ObjectSerializer::toQueryValue($is_to_single, null);
        }
        // query params
        if ($separator !== null) {
            $queryParams['separator'] = ObjectSerializer::toQueryValue($separator, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiConvertWebpagePost
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertWebpagePost($web_page = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiConvertWebpagePostWithHttpInfo($web_page, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertWebpagePostWithHttpInfo
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertWebpagePostWithHttpInfo($web_page = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsync
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsync($web_page = null, $output_type = null)
    {
        return $this->pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsyncWithHttpInfo
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertWebpagePost'
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertWebpagePostRequest($web_page = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/convert-webpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($web_page !== null) {
            $formParams['webPage'] = ObjectSerializer::toFormValue($web_page);
        }

        echo "FORM PARAMS:\n";
        print_r($formParams);
        echo "\n";

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCropPost
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCropPost($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiCropPostWithHttpInfo($files, $input_type, $top, $right, $bottom, $left, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCropPostWithHttpInfo
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCropPostWithHttpInfo($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $input_type, $top, $right, $bottom, $left, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCropPostAsync
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsync($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        return $this->pdfWebapiCropPostAsyncWithHttpInfo($files, $input_type, $top, $right, $bottom, $left, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCropPostAsyncWithHttpInfo
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsyncWithHttpInfo($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $input_type, $top, $right, $bottom, $left, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCropPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCropPostRequest($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/crop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // query params
        if ($right !== null) {
            $queryParams['right'] = ObjectSerializer::toQueryValue($right, 'int32');
        }
        // query params
        if ($bottom !== null) {
            $queryParams['bottom'] = ObjectSerializer::toQueryValue($bottom, 'int32');
        }
        // query params
        if ($left !== null) {
            $queryParams['left'] = ObjectSerializer::toQueryValue($left, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiDownloadIdGet
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pdfWebapiDownloadIdGet($id, $file = null)
    {
        $this->pdfWebapiDownloadIdGetWithHttpInfo($id, $file);
    }

    /**
     * Operation pdfWebapiDownloadIdGetWithHttpInfo
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiDownloadIdGetWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsync
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsync($id, $file = null)
    {
        return $this->pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsyncWithHttpInfo
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiDownloadIdGet'
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiDownloadIdGetRequest($id, $file = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiDownloadIdGet'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/download/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiEsignPost
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string $passw passw (optional)
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiEsignPost($passw = null, $files = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiEsignPostWithHttpInfo($passw, $files, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiEsignPostWithHttpInfo
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string $passw (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiEsignPostWithHttpInfo($passw = null, $files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($passw, $files, $input_type);

//        echo "Request: \n";
//        print_r($request);
//        echo "\n";

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiEsignPostAsync
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string $passw (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsync($passw = null, $files = null, $input_type = null)
    {
        return $this->pdfWebapiEsignPostAsyncWithHttpInfo($passw, $files, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiEsignPostAsyncWithHttpInfo
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string $passw (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsyncWithHttpInfo($passw = null, $files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($passw, $files, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiEsignPost'
     *
     * @param  string $passw (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiEsignPostRequest($passw = null, $files = null, $input_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($passw !== null) {
            $formParams['passw'] = ObjectSerializer::toFormValue($passw);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        echo "URL\n".$resourcePath . ($query ? "?{$query}" : '')."\n";
        
        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiExtractPost
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiExtractPost($files = null, $input_type = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiExtractPostWithHttpInfo($files, $input_type, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiExtractPostWithHttpInfo
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiExtractPostWithHttpInfo($files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $input_type, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiExtractPostAsync
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsync($files = null, $input_type = null, $output_type = null)
    {
        return $this->pdfWebapiExtractPostAsyncWithHttpInfo($files, $input_type, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiExtractPostAsyncWithHttpInfo
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $input_type, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiExtractPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiExtractPostRequest($files = null, $input_type = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiFormFillerPost
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiFormFillerPost($files = null, $file_name = null)
    {
        list($response) = $this->pdfWebapiFormFillerPostWithHttpInfo($files, $file_name);
        return $response;
    }

    /**
     * Operation pdfWebapiFormFillerPostWithHttpInfo
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiFormFillerPostWithHttpInfo($files = null, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiFormFillerPostRequest($files, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiFormFillerPostAsync
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiFormFillerPostAsync($files = null, $file_name = null)
    {
        return $this->pdfWebapiFormFillerPostAsyncWithHttpInfo($files, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiFormFillerPostAsyncWithHttpInfo
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiFormFillerPostAsyncWithHttpInfo($files = null, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiFormFillerPostRequest($files, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiFormFillerPost'
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiFormFillerPostRequest($files = null, $file_name = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/form-filler';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiGifPost
     *
     * Creates a GIF from the provided images.
     *
     * @param  string[] $files files (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiGifPost($files = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        list($response) = $this->pdfWebapiGifPostWithHttpInfo($files, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);
        return $response;
    }

    /**
     * Operation pdfWebapiGifPostWithHttpInfo
     *
     * Creates a GIF from the provided images.
     *
     * @param  string[] $files (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiGifPostWithHttpInfo($files = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($files, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiGifPostAsync
     *
     * Creates a GIF from the provided images.
     *
     * @param  string[] $files (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsync($files = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        return $this->pdfWebapiGifPostAsyncWithHttpInfo($files, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiGifPostAsyncWithHttpInfo
     *
     * Creates a GIF from the provided images.
     *
     * @param  string[] $files (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsyncWithHttpInfo($files = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($files, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiGifPost'
     *
     * @param  string[] $files (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiGifPostRequest($files = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($keep_images_as_is !== null) {
            $queryParams['keepImagesAsIs'] = ObjectSerializer::toQueryValue($keep_images_as_is, null);
        }
        // query params
        if ($resize_to_image !== null) {
            $queryParams['resizeToImage'] = ObjectSerializer::toQueryValue($resize_to_image, 'int32');
        }
        // query params
        if ($streched !== null) {
            $queryParams['streched'] = ObjectSerializer::toQueryValue($streched, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($frame_times !== null) {
            $queryParams['frameTimes'] = ObjectSerializer::toQueryValue($frame_times, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiHashPost
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiHashPost($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        list($response) = $this->pdfWebapiHashPostWithHttpInfo($files, $input_type, $output_type, $alg);
        return $response;
    }

    /**
     * Operation pdfWebapiHashPostWithHttpInfo
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiHashPostWithHttpInfo($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $input_type, $output_type, $alg);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiHashPostAsync
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsync($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        return $this->pdfWebapiHashPostAsyncWithHttpInfo($files, $input_type, $output_type, $alg)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiHashPostAsyncWithHttpInfo
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $input_type, $output_type, $alg);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiHashPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiHashPostRequest($files = null, $input_type = null, $output_type = null, $alg = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/hash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($alg !== null) {
            $queryParams['alg'] = ObjectSerializer::toQueryValue($alg, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiLockPost
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiLockPost($files = null, $passw = null)
    {
        list($response) = $this->pdfWebapiLockPostWithHttpInfo($files, $passw);
        return $response;
    }

    /**
     * Operation pdfWebapiLockPostWithHttpInfo
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiLockPostWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($files, $passw);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiLockPostAsync
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsync($files = null, $passw = null)
    {
        return $this->pdfWebapiLockPostAsyncWithHttpInfo($files, $passw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiLockPostAsyncWithHttpInfo
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsyncWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($files, $passw);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiLockPost'
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiLockPostRequest($files = null, $passw = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMergePost
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMergePost($files = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        list($response) = $this->pdfWebapiMergePostWithHttpInfo($files, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);
        return $response;
    }

    /**
     * Operation pdfWebapiMergePostWithHttpInfo
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMergePostWithHttpInfo($files = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMergePostAsync
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsync($files = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        return $this->pdfWebapiMergePostAsyncWithHttpInfo($files, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMergePostAsyncWithHttpInfo
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMergePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMergePostRequest($files = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($merge_type !== null) {
            $queryParams['mergeType'] = ObjectSerializer::toQueryValue($merge_type, null);
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }
        // query params
        if ($dc_is_landscape !== null) {
            $queryParams['dc_isLandscape'] = ObjectSerializer::toQueryValue($dc_is_landscape, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMetadataPost
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMetadataPost($files = null, $operation = null, $folder = null, $name = null)
    {
        list($response) = $this->pdfWebapiMetadataPostWithHttpInfo($files, $operation, $folder, $name);
        return $response;
    }

    /**
     * Operation pdfWebapiMetadataPostWithHttpInfo
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMetadataPostWithHttpInfo($files = null, $operation = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $operation, $folder, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMetadataPostAsync
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsync($files = null, $operation = null, $folder = null, $name = null)
    {
        return $this->pdfWebapiMetadataPostAsyncWithHttpInfo($files, $operation, $folder, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMetadataPostAsyncWithHttpInfo
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsyncWithHttpInfo($files = null, $operation = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $operation, $folder, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMetadataPost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMetadataPostRequest($files = null, $operation = null, $folder = null, $name = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operation !== null) {
            $queryParams['operation'] = ObjectSerializer::toQueryValue($operation, null);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiOrganizePost
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiOrganizePost($files = null, $input_type = null, $remove = null, $move = null)
    {
        list($response) = $this->pdfWebapiOrganizePostWithHttpInfo($files, $input_type, $remove, $move);
        return $response;
    }

    /**
     * Operation pdfWebapiOrganizePostWithHttpInfo
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiOrganizePostWithHttpInfo($files = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $input_type, $remove, $move);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiOrganizePostAsync
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsync($files = null, $input_type = null, $remove = null, $move = null)
    {
        return $this->pdfWebapiOrganizePostAsyncWithHttpInfo($files, $input_type, $remove, $move)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiOrganizePostAsyncWithHttpInfo
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsyncWithHttpInfo($files = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $input_type, $remove, $move);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiOrganizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiOrganizePostRequest($files = null, $input_type = null, $remove = null, $move = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Organize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($remove !== null) {
            $queryParams['remove'] = ObjectSerializer::toQueryValue($remove, null);
        }
        // query params
        if ($move !== null) {
            $queryParams['move'] = ObjectSerializer::toQueryValue($move, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiParsePost
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiParsePost($files = null)
    {
        list($response) = $this->pdfWebapiParsePostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiParsePostWithHttpInfo
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiParsePostWithHttpInfo($files = null)
    {

        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiParsePostAsync
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsync($files = null)
    {
        return $this->pdfWebapiParsePostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiParsePostAsyncWithHttpInfo
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiParsePost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiParsePostRequest($files = null)
    {
        $resourcePath = 'http://localhost:5000/pdf/webapi/parse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRedactPost
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRedactPost($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        list($response) = $this->pdfWebapiRedactPostWithHttpInfo($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);
        return $response;
    }

    /**
     * Operation pdfWebapiRedactPostWithHttpInfo
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRedactPostWithHttpInfo($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRedactPostAsync
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsync($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        return $this->pdfWebapiRedactPostAsyncWithHttpInfo($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRedactPostAsyncWithHttpInfo
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsyncWithHttpInfo($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRedactPost'
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRedactPostRequest($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/redact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_query !== null) {
            $queryParams['searchQuery'] = ObjectSerializer::toQueryValue($search_query, null);
        }
        // query params
        if ($replace_text !== null) {
            $queryParams['replaceText'] = ObjectSerializer::toQueryValue($replace_text, null);
        }
        // query params
        if ($case_sensitive !== null) {
            $queryParams['caseSensitive'] = ObjectSerializer::toQueryValue($case_sensitive, null);
        }
        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text, null);
        }
        // query params
        if ($comments !== null) {
            $queryParams['comments'] = ObjectSerializer::toQueryValue($comments, null);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveIdPost
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveIdPost($id)
    {
        list($response) = $this->pdfWebapiRemoveIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveIdPostWithHttpInfo
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsync
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsync($id)
    {
        return $this->pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsyncWithHttpInfo
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveIdPost'
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiRemoveIdPost'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovePost
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovePost($files = null)
    {
        list($response) = $this->pdfWebapiRemovePostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovePostWithHttpInfo
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovePostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovePostAsync
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsync($files = null)
    {
        return $this->pdfWebapiRemovePostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovePostAsyncWithHttpInfo
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovePost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovePostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPost
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text watermark_text (optional)
     * @param  int $top top (optional)
     * @param  int $left left (optional)
     * @param  int $bottom bottom (optional)
     * @param  int $right right (optional)
     * @param  string[] $files files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveWatermarkPost($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostWithHttpInfo
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsync
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsync($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        return $this->pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveWatermarkPost'
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveWatermarkPostRequest($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove-watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_all_pages !== null) {
            $queryParams['isAllPages'] = ObjectSerializer::toQueryValue($is_all_pages, null);
        }
        // query params
        if ($watermark_type !== null) {
            $queryParams['watermarkType'] = ObjectSerializer::toQueryValue($watermark_type, null);
        }
        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }


        // form params
        if ($watermark_text !== null) {
            $formParams['watermarkText'] = ObjectSerializer::toFormValue($watermark_text);
        }
        // form params
        if ($top !== null) {
            $formParams['top'] = ObjectSerializer::toFormValue($top);
        }
        // form params
        if ($left !== null) {
            $formParams['left'] = ObjectSerializer::toFormValue($left);
        }
        // form params
        if ($bottom !== null) {
            $formParams['bottom'] = ObjectSerializer::toFormValue($bottom);
        }
        // form params
        if ($right !== null) {
            $formParams['right'] = ObjectSerializer::toFormValue($right);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovepagesPost
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovepagesPost($files = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemovepagesPostWithHttpInfo($files, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovepagesPostWithHttpInfo
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovepagesPostWithHttpInfo($files = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsync
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsync($files = null, $remove_range = null)
    {
        return $this->pdfWebapiRemovepagesPostAsyncWithHttpInfo($files, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsyncWithHttpInfo
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsyncWithHttpInfo($files = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovepagesPost'
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovepagesPostRequest($files = null, $remove_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/removepages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }

                // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);


        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRepairPost
     *
     * Repairs the provided files.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRepairPost($files = null)
    {
        list($response) = $this->pdfWebapiRepairPostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiRepairPostWithHttpInfo
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRepairPostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRepairPostAsync
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsync($files = null)
    {
        return $this->pdfWebapiRepairPostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRepairPostAsyncWithHttpInfo
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRepairPost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRepairPostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/repair';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiResizePost
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiResizePost($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        list($response) = $this->pdfWebapiResizePostWithHttpInfo($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);
        return $response;
    }

    /**
     * Operation pdfWebapiResizePostWithHttpInfo
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiResizePostWithHttpInfo($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiResizePostAsync
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsync($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        return $this->pdfWebapiResizePostAsyncWithHttpInfo($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiResizePostAsyncWithHttpInfo
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiResizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiResizePostRequest($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/resize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($resize_type !== null) {
            $queryParams['resizeType'] = ObjectSerializer::toQueryValue($resize_type, null);
        }
        // query params
        if ($preset_type !== null) {
            $queryParams['presetType'] = ObjectSerializer::toQueryValue($preset_type, null);
        }
        // query params
        if ($preset_size !== null) {
            $queryParams['presetSize'] = ObjectSerializer::toQueryValue($preset_size, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($percentage !== null) {
            $queryParams['percentage'] = ObjectSerializer::toQueryValue($percentage, 'int32');
        }
        // query params
        if ($use_proportions !== null) {
            $queryParams['useProportions'] = ObjectSerializer::toQueryValue($use_proportions, null);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRotatePost
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRotatePost($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        list($response) = $this->pdfWebapiRotatePostWithHttpInfo($files, $angle, $rotate_type, $page_num);
        return $response;
    }

    /**
     * Operation pdfWebapiRotatePostWithHttpInfo
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRotatePostWithHttpInfo($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $angle, $rotate_type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRotatePostAsync
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsync($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        return $this->pdfWebapiRotatePostAsyncWithHttpInfo($files, $angle, $rotate_type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRotatePostAsyncWithHttpInfo
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsyncWithHttpInfo($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $angle, $rotate_type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRotatePost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRotatePostRequest($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/rotate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($angle !== null) {
            $queryParams['angle'] = ObjectSerializer::toQueryValue($angle, null);
        }
        // query params
        if ($rotate_type !== null) {
            $queryParams['rotateType'] = ObjectSerializer::toQueryValue($rotate_type, null);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchPost
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchPost($files = null, $query = null)
    {
        list($response) = $this->pdfWebapiSearchPostWithHttpInfo($files, $query);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchPostWithHttpInfo
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchPostWithHttpInfo($files = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchPostAsync
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsync($files = null, $query = null)
    {
        return $this->pdfWebapiSearchPostAsyncWithHttpInfo($files, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchPostAsyncWithHttpInfo
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsyncWithHttpInfo($files = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchPost'
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchPostRequest($files = null, $query = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchablePost
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchablePost($files = null, $lang = null)
    {
        list($response) = $this->pdfWebapiSearchablePostWithHttpInfo($files, $lang);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchablePostWithHttpInfo
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchablePostWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchablePostAsync
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsync($files = null, $lang = null)
    {
        return $this->pdfWebapiSearchablePostAsyncWithHttpInfo($files, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchablePostAsyncWithHttpInfo
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsyncWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchablePost'
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchablePostRequest($files = null, $lang = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/searchable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSignaturePost
     *
     * Adds a signature to the provided files.
     *
     * @param  string $image image (optional)
     * @param  string $text text (optional)
     * @param  string $text_color text_color (optional)
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSignaturePost($image = null, $text = null, $text_color = null, $files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        list($response) = $this->pdfWebapiSignaturePostWithHttpInfo($image, $text, $text_color, $files, $input_type, $output_type, $signature_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSignaturePostWithHttpInfo
     *
     * Adds a signature to the provided files.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSignaturePostWithHttpInfo($image = null, $text = null, $text_color = null, $files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($image, $text, $text_color, $files, $input_type, $output_type, $signature_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSignaturePostAsync
     *
     * Adds a signature to the provided files.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsync($image = null, $text = null, $text_color = null, $files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        return $this->pdfWebapiSignaturePostAsyncWithHttpInfo($image, $text, $text_color, $files, $input_type, $output_type, $signature_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSignaturePostAsyncWithHttpInfo
     *
     * Adds a signature to the provided files.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsyncWithHttpInfo($image = null, $text = null, $text_color = null, $files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($image, $text, $text_color, $files, $input_type, $output_type, $signature_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSignaturePost'
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSignaturePostRequest($image = null, $text = null, $text_color = null, $files = null, $input_type = null, $output_type = null, $signature_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Signature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($signature_type !== null) {
            $queryParams['signatureType'] = ObjectSerializer::toQueryValue($signature_type, null);
        }


        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = ObjectSerializer::toFormValue($text);
        }
        // form params
        if ($text_color !== null) {
            $formParams['textColor'] = ObjectSerializer::toFormValue($text_color);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitdocPost
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitdocPost($files = null, $split_type = null, $pars = null)
    {
        list($response) = $this->pdfWebapiSplitdocPostWithHttpInfo($files, $split_type, $pars);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitdocPostWithHttpInfo
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitdocPostWithHttpInfo($files = null, $split_type = null, $pars = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $split_type, $pars);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitdocPostAsync
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsync($files = null, $split_type = null, $pars = null)
    {
        return $this->pdfWebapiSplitdocPostAsyncWithHttpInfo($files, $split_type, $pars)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitdocPostAsyncWithHttpInfo
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsyncWithHttpInfo($files = null, $split_type = null, $pars = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $split_type, $pars);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitdocPost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitdocPostRequest($files = null, $split_type = null, $pars = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/splitdoc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, null);
        }
        // query params
        if ($pars !== null) {
            $queryParams['pars'] = ObjectSerializer::toQueryValue($pars, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitimagePost
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files files (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitimagePost($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiSplitimagePostWithHttpInfo($files, $split_type, $vertical, $horizontal, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitimagePostWithHttpInfo
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitimagePostWithHttpInfo($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $split_type, $vertical, $horizontal, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitimagePostAsync
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsync($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        return $this->pdfWebapiSplitimagePostAsyncWithHttpInfo($files, $split_type, $vertical, $horizontal, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitimagePostAsyncWithHttpInfo
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsyncWithHttpInfo($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $split_type, $vertical, $horizontal, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitimagePost'
     *
     * @param  string[] $files (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitimagePostRequest($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/splitimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, null);
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiStatusIdPost
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiStatusIdPost($id)
    {
        list($response) = $this->pdfWebapiStatusIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiStatusIdPostWithHttpInfo
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiStatusIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiStatusIdPostAsync
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsync($id)
    {
        return $this->pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiStatusIdPostAsyncWithHttpInfo
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiStatusIdPost'
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiStatusIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiStatusIdPost'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/status/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiUnlockPost
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiUnlockPost($files = null, $passw = null)
    {
        list($response) = $this->pdfWebapiUnlockPostWithHttpInfo($files, $passw);
        return $response;
    }

    /**
     * Operation pdfWebapiUnlockPostWithHttpInfo
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiUnlockPostWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($files, $passw);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiUnlockPostAsync
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsync($files = null, $passw = null)
    {
        return $this->pdfWebapiUnlockPostAsyncWithHttpInfo($files, $passw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiUnlockPostAsyncWithHttpInfo
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsyncWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($files, $passw);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiUnlockPost'
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiUnlockPostRequest($files = null, $passw = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiVerifyEsignPost
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiVerifyEsignPost($files = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiVerifyEsignPostWithHttpInfo($files, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiVerifyEsignPostWithHttpInfo
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiVerifyEsignPostWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsync
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsync($files = null, $input_type = null)
    {
        return $this->pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsyncWithHttpInfo
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiVerifyEsignPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiVerifyEsignPostRequest($files = null, $input_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/verify_esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request = new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );

        return  $request;
    }

    /**
     * Operation pdfWebapiWatermarkPost
     *
     * Adds a watermark to the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWatermarkPost($files = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        list($response) = $this->pdfWebapiWatermarkPostWithHttpInfo($files, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);
        return $response;
    }

    /**
     * Operation pdfWebapiWatermarkPostWithHttpInfo
     *
     * Add watermark to document.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWatermarkPostWithHttpInfo($files = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($files, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWatermarkPostAsync
     *
     * Adds a watermark to the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsync($files = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        return $this->pdfWebapiWatermarkPostAsyncWithHttpInfo($files, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWatermarkPostAsyncWithHttpInfo
     *
     * Adds a watermark to the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($files, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWatermarkPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWatermarkPostRequest($files = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($is_colored !== null) {
            $queryParams['isColored'] = ObjectSerializer::toQueryValue($is_colored, null);
        }
        // query params
        if ($is_text !== null) {
            $queryParams['isText'] = ObjectSerializer::toQueryValue($is_text, null);
        }
        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($bold !== null) {
            $queryParams['bold'] = ObjectSerializer::toQueryValue($bold, null);
        }
        // query params
        if ($italic !== null) {
            $queryParams['italic'] = ObjectSerializer::toQueryValue($italic, null);
        }
        // query params
        if ($underlined !== null) {
            $queryParams['underlined'] = ObjectSerializer::toQueryValue($underlined, null);
        }
        // query params
        if ($color !== null) {
            $queryParams['color'] = ObjectSerializer::toQueryValue($color, null);
        }
        // query params
        if ($is_background !== null) {
            $queryParams['isBackground'] = ObjectSerializer::toQueryValue($is_background, null);
        }
        // query params
        if ($rotation !== null) {
            $queryParams['rotation'] = ObjectSerializer::toQueryValue($rotation, 'int32');
        }
        // query params
        if ($transparency !== null) {
            $queryParams['transparency'] = ObjectSerializer::toQueryValue($transparency, 'float');
        }
        // query params
        if ($layer !== null) {
            $queryParams['layer'] = ObjectSerializer::toQueryValue($layer, null);
        }
        // query params
        if ($page_from !== null) {
            $queryParams['pageFrom'] = ObjectSerializer::toQueryValue($page_from, 'int32');
        }
        // query params
        if ($page_to !== null) {
            $queryParams['pageTo'] = ObjectSerializer::toQueryValue($page_to, 'int32');
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiWordcounterPost
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWordcounterPost($files = null, $page_range = null)
    {
        list($response) = $this->pdfWebapiWordcounterPostWithHttpInfo($files, $page_range);
        return $response;
    }

    /**
     * Operation pdfWebapiWordcounterPostWithHttpInfo
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWordcounterPostWithHttpInfo($files = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordcounterPostRequest($files, $page_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWordcounterPostAsync
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordcounterPostAsync($files = null, $page_range = null)
    {
        return $this->pdfWebapiWordcounterPostAsyncWithHttpInfo($files, $page_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWordcounterPostAsyncWithHttpInfo
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordcounterPostAsyncWithHttpInfo($files = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordcounterPostRequest($files, $page_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWordcounterPost'
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWordcounterPostRequest($files = null, $page_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/WordCounter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_range !== null) {
            $queryParams['pageRange'] = ObjectSerializer::toQueryValue($page_range, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiXfaconvertPost
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiXfaconvertPost($files = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiXfaconvertPostWithHttpInfo($files, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiXfaconvertPostWithHttpInfo
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiXfaconvertPostWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsync
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsync($files = null, $input_type = null)
    {
        return $this->pdfWebapiXfaconvertPostAsyncWithHttpInfo($files, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsyncWithHttpInfo
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsyncWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiXfaconvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiXfaconvertPostRequest($files = null, $input_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/xfaconvert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
             $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
