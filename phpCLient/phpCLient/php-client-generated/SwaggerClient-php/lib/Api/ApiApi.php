<?php
/**
 * ApiApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Aspose.Pdf RestApi
 *
 * Demo 1
 *
 * OpenAPI spec version: v1
 * Contact: Evgeny.Pirogov@aspose.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Stream;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ApiApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ApiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pdfWebapiAddnumberPost
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files files (optional)
     * @param  string $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  string $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiAddnumberPost($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        list($response) = $this->pdfWebapiAddnumberPostWithHttpInfo($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);
        return $response;
    }

    /**
     * Operation pdfWebapiAddnumberPostWithHttpInfo
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  string $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  string $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiAddnumberPostWithHttpInfo($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiAddnumberPostAsync
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  string $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  string $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsync($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        return $this->pdfWebapiAddnumberPostAsyncWithHttpInfo($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiAddnumberPostAsyncWithHttpInfo
     *
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     *
     * @param  string[] $files (optional)
     * @param  string $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  string $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsyncWithHttpInfo($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiAddnumberPost'
     *
     * @param  string[] $files (optional)
     * @param  string $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  string $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiAddnumberPostRequest($files = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/addnumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '123';
        $multipart = false;

        // query params
        if ($v_alignment !== null) {
            $queryParams['vAlignment'] = ObjectSerializer::toQueryValue($v_alignment, null);
        }
        // query params
        if ($h_alignment !== null) {
            $queryParams['hAlignment'] = ObjectSerializer::toQueryValue($h_alignment, null);
        }
        // query params
        if ($starting_number !== null) {
            $queryParams['startingNumber'] = ObjectSerializer::toQueryValue($starting_number, 'int32');
        }
        // query params
        if ($s_number !== null) {
            $queryParams['sNumber'] = ObjectSerializer::toQueryValue($s_number, 'int32');
        }
        // query params
        if ($f_number !== null) {
            $queryParams['fNumber'] = ObjectSerializer::toQueryValue($f_number, 'int32');
        }
        // query params
        if ($margin !== null) {
            $queryParams['margin'] = ObjectSerializer::toQueryValue($margin, 'int32');
        }
        // query params
        if ($font_size !== null) {
            $queryParams['fontSize'] = ObjectSerializer::toQueryValue($font_size, 'int32');
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiBinaryComparisonPost
     *
     * Performs a binary comparison on the provided files.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiBinaryComparisonPost($files = null)
    {
        list($response) = $this->pdfWebapiBinaryComparisonPostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiBinaryComparisonPostWithHttpInfo
     *
     * Performs a binary comparison on the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiBinaryComparisonPostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiBinaryComparisonPostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiBinaryComparisonPostAsync
     *
     * Performs a binary comparison on the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiBinaryComparisonPostAsync($files = null)
    {
        return $this->pdfWebapiBinaryComparisonPostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiBinaryComparisonPostAsyncWithHttpInfo
     *
     * Performs a binary comparison on the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiBinaryComparisonPostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiBinaryComparisonPostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiBinaryComparisonPost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiBinaryComparisonPostRequest($files = null)
    {

        $resourcePath = '/pdf/webapi/BinaryComparison';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiChatpdfPost
     *
     * Generates a PDF document based on the provided files and question.
     *
     * @param  string[] $files files (optional)
     * @param  int $mode The mode of operation for the PDF generation. (optional)
     * @param  string $question The question to be included in the PDF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiChatpdfPost($files = null, $mode = null, $question = null)
    {
        list($response) = $this->pdfWebapiChatpdfPostWithHttpInfo($files, $mode, $question);
        return $response;
    }

    /**
     * Operation pdfWebapiChatpdfPostWithHttpInfo
     *
     * Generates a PDF document based on the provided files and question.
     *
     * @param  string[] $files (optional)
     * @param  int $mode The mode of operation for the PDF generation. (optional)
     * @param  string $question The question to be included in the PDF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiChatpdfPostWithHttpInfo($files = null, $mode = null, $question = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChatpdfPostRequest($files, $mode, $question);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiChatpdfPostAsync
     *
     * Generates a PDF document based on the provided files and question.
     *
     * @param  string[] $files (optional)
     * @param  int $mode The mode of operation for the PDF generation. (optional)
     * @param  string $question The question to be included in the PDF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChatpdfPostAsync($files = null, $mode = null, $question = null)
    {
        return $this->pdfWebapiChatpdfPostAsyncWithHttpInfo($files, $mode, $question)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiChatpdfPostAsyncWithHttpInfo
     *
     * Generates a PDF document based on the provided files and question.
     *
     * @param  string[] $files (optional)
     * @param  int $mode The mode of operation for the PDF generation. (optional)
     * @param  string $question The question to be included in the PDF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChatpdfPostAsyncWithHttpInfo($files = null, $mode = null, $question = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChatpdfPostRequest($files, $mode, $question);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiChatpdfPost'
     *
     * @param  string[] $files (optional)
     * @param  int $mode The mode of operation for the PDF generation. (optional)
     * @param  string $question The question to be included in the PDF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiChatpdfPostRequest($files = null, $mode = null, $question = null)
    {

        $resourcePath = '/pdf/webapi/chatpdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode, 'int32');
        }
        // query params
        if ($question !== null) {
            $queryParams['question'] = ObjectSerializer::toQueryValue($question, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiComparisonPost
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiComparisonPost($files = null)
    {
        list($response) = $this->pdfWebapiComparisonPostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiComparisonPostWithHttpInfo
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiComparisonPostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiComparisonPostAsync
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsync($files = null)
    {
        return $this->pdfWebapiComparisonPostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiComparisonPostAsyncWithHttpInfo
     *
     * Compare provided files and create document with marked changes.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiComparisonPost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiComparisonPostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Comparison';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCompressPost
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files files (optional)
     * @param  int $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCompressPost($files = null, $compress_type = null)
    {
        list($response) = $this->pdfWebapiCompressPostWithHttpInfo($files, $compress_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCompressPostWithHttpInfo
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  int $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCompressPostWithHttpInfo($files = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $compress_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();

            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCompressPostAsync
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  int $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsync($files = null, $compress_type = null)
    {
        return $this->pdfWebapiCompressPostAsyncWithHttpInfo($files, $compress_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCompressPostAsyncWithHttpInfo
     *
     * Compresses the provided files using the specified compression level.
     *
     * @param  string[] $files (optional)
     * @param  int $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsyncWithHttpInfo($files = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $compress_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCompressPost'
     *
     * @param  string[] $files (optional)
     * @param  int $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCompressPostRequest($files = null, $compress_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_type !== null) {
            $queryParams['compressType'] = ObjectSerializer::toQueryValue($compress_type, 'int32');
        }

        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }

        // body params
        $_tempBody = null;


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
//                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request =  new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
        return $request;
    }

    /**
     * Operation pdfWebapiConvertPost
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertPost($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        list($response) = $this->pdfWebapiConvertPostWithHttpInfo($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertPostWithHttpInfo
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertPostWithHttpInfo($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertPostAsync
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsync($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        return $this->pdfWebapiConvertPostAsyncWithHttpInfo($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertPostAsyncWithHttpInfo
     *
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertPostRequest($files = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($xml_type !== null) {
            $queryParams['xmlType'] = ObjectSerializer::toQueryValue($xml_type, 'int32');
        }
        // query params
        if ($xml_tag !== null) {
            $queryParams['xmlTag'] = ObjectSerializer::toQueryValue($xml_tag, null);
        }
        // query params
        if ($font_sise !== null) {
            $queryParams['fontSise'] = ObjectSerializer::toQueryValue($font_sise, 'int32');
        }
        // query params
        if ($is_to_single !== null) {
            $queryParams['isToSingle'] = ObjectSerializer::toQueryValue($is_to_single, null);
        }
        // query params
        if ($separator !== null) {
            $queryParams['separator'] = ObjectSerializer::toQueryValue($separator, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiConvertWebpagePost
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertWebpagePost($web_page = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiConvertWebpagePostWithHttpInfo($web_page, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertWebpagePostWithHttpInfo
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertWebpagePostWithHttpInfo($web_page = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsync
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsync($web_page = null, $output_type = null)
    {
        return $this->pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsyncWithHttpInfo
     *
     * Converts a web page to the specified output format.
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertWebpagePost'
     *
     * @param  string $web_page (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertWebpagePostRequest($web_page = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/convert-webpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($web_page !== null) {
            $formParams['webPage'] = ObjectSerializer::toFormValue($web_page);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCropPost
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCropPost($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiCropPostWithHttpInfo($files, $input_type, $top, $right, $bottom, $left, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCropPostWithHttpInfo
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCropPostWithHttpInfo($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $input_type, $top, $right, $bottom, $left, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCropPostAsync
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsync($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        return $this->pdfWebapiCropPostAsyncWithHttpInfo($files, $input_type, $top, $right, $bottom, $left, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCropPostAsyncWithHttpInfo
     *
     * Crops the provided files to the specified dimensions.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsyncWithHttpInfo($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $input_type, $top, $right, $bottom, $left, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCropPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCropPostRequest($files = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/crop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // query params
        if ($right !== null) {
            $queryParams['right'] = ObjectSerializer::toQueryValue($right, 'int32');
        }
        // query params
        if ($bottom !== null) {
            $queryParams['bottom'] = ObjectSerializer::toQueryValue($bottom, 'int32');
        }
        // query params
        if ($left !== null) {
            $queryParams['left'] = ObjectSerializer::toQueryValue($left, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiDownloadIdGet
     *
     * Downloads a file.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pdfWebapiDownloadIdGet($id, $file = null)
    {
        $this->pdfWebapiDownloadIdGetWithHttpInfo($id, $file);
    }

    /**
     * Operation pdfWebapiDownloadIdGetWithHttpInfo
     *
     * Downloads a file.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiDownloadIdGetWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsync
     *
     * Downloads a file.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsync($id, $file = null)
    {
        return $this->pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsyncWithHttpInfo
     *
     * Downloads a file.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiDownloadIdGet'
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiDownloadIdGetRequest($id, $file = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiDownloadIdGet'
            );
        }

        $resourcePath = '/pdf/webapi/download/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiDownloadStreamIdPost
     *
     * Downloads a file as a stream.
     *
     * @param  string $id The ID of the processing to download. (required)
     * @param  string $file_name The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiDownloadStreamIdPost($id, $file_name = null)
    {
        list($response) = $this->pdfWebapiDownloadStreamIdPostWithHttpInfo($id, $file_name);
        return $response;
    }

    /**
     * Operation pdfWebapiDownloadStreamIdPostWithHttpInfo
     *
     * Downloads a file as a stream.
     *
     * @param  string $id The ID of the processing to download. (required)
     * @param  string $file_name The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiDownloadStreamIdPostWithHttpInfo($id, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiDownloadStreamIdPostRequest($id, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiDownloadStreamIdPostAsync
     *
     * Downloads a file as a stream.
     *
     * @param  string $id The ID of the processing to download. (required)
     * @param  string $file_name The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadStreamIdPostAsync($id, $file_name = null)
    {
        return $this->pdfWebapiDownloadStreamIdPostAsyncWithHttpInfo($id, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiDownloadStreamIdPostAsyncWithHttpInfo
     *
     * Downloads a file as a stream.
     *
     * @param  string $id The ID of the processing to download. (required)
     * @param  string $file_name The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadStreamIdPostAsyncWithHttpInfo($id, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiDownloadStreamIdPostRequest($id, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiDownloadStreamIdPost'
     *
     * @param  string $id The ID of the processing to download. (required)
     * @param  string $file_name The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiDownloadStreamIdPostRequest($id, $file_name = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiDownloadStreamIdPost'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/download-stream/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiEsignPost
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $passw The password to use for electronic signing. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiEsignPost($files = null, $input_type = null, $passw = null)
    {
        list($response) = $this->pdfWebapiEsignPostWithHttpInfo($files, $input_type, $passw);
        return $response;
    }

    /**
     * Operation pdfWebapiEsignPostWithHttpInfo
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $passw The password to use for electronic signing. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiEsignPostWithHttpInfo($files = null, $input_type = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($files, $input_type, $passw);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiEsignPostAsync
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $passw The password to use for electronic signing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsync($files = null, $input_type = null, $passw = null)
    {
        return $this->pdfWebapiEsignPostAsyncWithHttpInfo($files, $input_type, $passw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiEsignPostAsyncWithHttpInfo
     *
     * Electronically signs the provided files with the specified certificate and its password.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $passw The password to use for electronic signing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsyncWithHttpInfo($files = null, $input_type = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($files, $input_type, $passw);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiEsignPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $passw The password to use for electronic signing. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiEsignPostRequest($files = null, $input_type = null, $passw = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiExtractPost
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiExtractPost($files = null, $input_type = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiExtractPostWithHttpInfo($files, $input_type, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiExtractPostWithHttpInfo
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiExtractPostWithHttpInfo($files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $input_type, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiExtractPostAsync
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsync($files = null, $input_type = null, $output_type = null)
    {
        return $this->pdfWebapiExtractPostAsyncWithHttpInfo($files, $input_type, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiExtractPostAsyncWithHttpInfo
     *
     * Extracts tables from the provided documents and converts them to the specified output format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $input_type, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiExtractPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiExtractPostRequest($files = null, $input_type = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiFormFillerPost
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiFormFillerPost($files = null, $file_name = null)
    {
        list($response) = $this->pdfWebapiFormFillerPostWithHttpInfo($files, $file_name);
        return $response;
    }

    /**
     * Operation pdfWebapiFormFillerPostWithHttpInfo
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiFormFillerPostWithHttpInfo($files = null, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiFormFillerPostRequest($files, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiFormFillerPostAsync
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiFormFillerPostAsync($files = null, $file_name = null)
    {
        return $this->pdfWebapiFormFillerPostAsyncWithHttpInfo($files, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiFormFillerPostAsyncWithHttpInfo
     *
     * Fills a form with the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiFormFillerPostAsyncWithHttpInfo($files = null, $file_name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiFormFillerPostRequest($files, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiFormFillerPost'
     *
     * @param  string[] $files (optional)
     * @param  string $file_name The name of the file to fill the form with. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiFormFillerPostRequest($files = null, $file_name = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/form-filler';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

//                $multipartContents = [];
//                foreach ($formParams as $formParamName => $formParamValue) {
//                    $multipartContents[] = [
//                        'name' => $formParamName,
//                        'contents' => $formParamValue
//                    ];
//                }
                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiGifPost
     *
     * Creates a GIF from the provided images.
     *
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiGifPost($keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        list($response) = $this->pdfWebapiGifPostWithHttpInfo($keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);
        return $response;
    }

    /**
     * Operation pdfWebapiGifPostWithHttpInfo
     *
     * Creates a GIF from the provided images.
     *
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiGifPostWithHttpInfo($keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiGifPostAsync
     *
     * Creates a GIF from the provided images.
     *
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsync($keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        return $this->pdfWebapiGifPostAsyncWithHttpInfo($keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiGifPostAsyncWithHttpInfo
     *
     * Creates a GIF from the provided images.
     *
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsyncWithHttpInfo($keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiGifPost'
     *
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiGifPostRequest($keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($keep_images_as_is !== null) {
            $queryParams['keepImagesAsIs'] = ObjectSerializer::toQueryValue($keep_images_as_is, null);
        }
        // query params
        if ($resize_to_image !== null) {
            $queryParams['resizeToImage'] = ObjectSerializer::toQueryValue($resize_to_image, 'int32');
        }
        // query params
        if ($streched !== null) {
            $queryParams['streched'] = ObjectSerializer::toQueryValue($streched, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($frame_times !== null) {
            $queryParams['frameTimes'] = ObjectSerializer::toQueryValue($frame_times, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''), //$this->config->getHost() . 
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiHashPost
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiHashPost($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        list($response) = $this->pdfWebapiHashPostWithHttpInfo($files, $input_type, $output_type, $alg);
        return $response;
    }

    /**
     * Operation pdfWebapiHashPostWithHttpInfo
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiHashPostWithHttpInfo($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $input_type, $output_type, $alg);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiHashPostAsync
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsync($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        return $this->pdfWebapiHashPostAsyncWithHttpInfo($files, $input_type, $output_type, $alg)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiHashPostAsyncWithHttpInfo
     *
     * Hashes the provided files using the specified algorithm.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $input_type, $output_type, $alg);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiHashPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiHashPostRequest($files = null, $input_type = null, $output_type = null, $alg = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/hash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($alg !== null) {
            $queryParams['alg'] = ObjectSerializer::toQueryValue($alg, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiLockPost
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiLockPost($files = null, $passw = null)
    {
        list($response) = $this->pdfWebapiLockPostWithHttpInfo($files, $passw);
        return $response;
    }

    /**
     * Operation pdfWebapiLockPostWithHttpInfo
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiLockPostWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($files, $passw);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiLockPostAsync
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsync($files = null, $passw = null)
    {
        return $this->pdfWebapiLockPostAsyncWithHttpInfo($files, $passw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiLockPostAsyncWithHttpInfo
     *
     * Locks a document with the provided password and optional files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsyncWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($files, $passw);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiLockPost'
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password required to lock the resource. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiLockPostRequest($files = null, $passw = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMergePost
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  string $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMergePost($files = null, $input_type = null, $output_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        list($response) = $this->pdfWebapiMergePostWithHttpInfo($files, $input_type, $output_type, $horizontal, $vertical, $page_size, $dc_is_landscape);
        return $response;
    }

    /**
     * Operation pdfWebapiMergePostWithHttpInfo
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  string $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMergePostWithHttpInfo($files = null, $input_type = null, $output_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $input_type, $output_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMergePostAsync
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  string $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsync($files = null, $input_type = null, $output_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        return $this->pdfWebapiMergePostAsyncWithHttpInfo($files, $input_type, $output_type, $horizontal, $vertical, $page_size, $dc_is_landscape)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMergePostAsyncWithHttpInfo
     *
     * Merges the provided files into a single document or image, with options for orientation and page size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  string $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $input_type, $output_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMergePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  string $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMergePostRequest($files = null, $input_type = null, $output_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }
        // query params
        if ($dc_is_landscape !== null) {
            $queryParams['dc_isLandscape'] = ObjectSerializer::toQueryValue($dc_is_landscape, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMetadataPost
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $opration opration (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMetadataPost($files = null, $opration = null, $folder = null, $name = null)
    {
        list($response) = $this->pdfWebapiMetadataPostWithHttpInfo($files, $opration, $folder, $name);
        return $response;
    }

    /**
     * Operation pdfWebapiMetadataPostWithHttpInfo
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $opration (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMetadataPostWithHttpInfo($files = null, $opration = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $opration, $folder, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMetadataPostAsync
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $opration (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsync($files = null, $opration = null, $folder = null, $name = null)
    {
        return $this->pdfWebapiMetadataPostAsyncWithHttpInfo($files, $opration, $folder, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMetadataPostAsyncWithHttpInfo
     *
     * Performs metadata operations on the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $opration (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsyncWithHttpInfo($files = null, $opration = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $opration, $folder, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMetadataPost'
     *
     * @param  string[] $files (optional)
     * @param  string $opration (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMetadataPostRequest($files = null, $opration = null, $folder = null, $name = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($opration !== null) {
            $queryParams['opration'] = ObjectSerializer::toQueryValue($opration, null);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMusicVideoPost
     *
     * Creates a music video from the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  int $interval The interval between frames in the music video. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMusicVideoPost($files = null, $interval = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiMusicVideoPostWithHttpInfo($files, $interval, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiMusicVideoPostWithHttpInfo
     *
     * Creates a music video from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  int $interval The interval between frames in the music video. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMusicVideoPostWithHttpInfo($files = null, $interval = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMusicVideoPostRequest($files, $interval, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMusicVideoPostAsync
     *
     * Creates a music video from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  int $interval The interval between frames in the music video. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMusicVideoPostAsync($files = null, $interval = null, $output_type = null)
    {
        return $this->pdfWebapiMusicVideoPostAsyncWithHttpInfo($files, $interval, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMusicVideoPostAsyncWithHttpInfo
     *
     * Creates a music video from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  int $interval The interval between frames in the music video. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMusicVideoPostAsyncWithHttpInfo($files = null, $interval = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMusicVideoPostRequest($files, $interval, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMusicVideoPost'
     *
     * @param  string[] $files (optional)
     * @param  int $interval The interval between frames in the music video. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMusicVideoPostRequest($files = null, $interval = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/music-video';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($interval !== null) {
            $queryParams['interval'] = ObjectSerializer::toQueryValue($interval, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiOrganizePost
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiOrganizePost($files = null, $input_type = null, $remove = null, $move = null)
    {
        list($response) = $this->pdfWebapiOrganizePostWithHttpInfo($files, $input_type, $remove, $move);
        return $response;
    }

    /**
     * Operation pdfWebapiOrganizePostWithHttpInfo
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiOrganizePostWithHttpInfo($files = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $input_type, $remove, $move);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiOrganizePostAsync
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsync($files = null, $input_type = null, $remove = null, $move = null)
    {
        return $this->pdfWebapiOrganizePostAsyncWithHttpInfo($files, $input_type, $remove, $move)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiOrganizePostAsyncWithHttpInfo
     *
     * Organizes the provided documents by removing or moving specified pages.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsyncWithHttpInfo($files = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $input_type, $remove, $move);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiOrganizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiOrganizePostRequest($files = null, $input_type = null, $remove = null, $move = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Organize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($remove !== null) {
            $queryParams['remove'] = ObjectSerializer::toQueryValue($remove, null);
        }
        // query params
        if ($move !== null) {
            $queryParams['move'] = ObjectSerializer::toQueryValue($move, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiParsePost
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiParsePost($files = null)
    {
        list($response) = $this->pdfWebapiParsePostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiParsePostWithHttpInfo
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiParsePostWithHttpInfo($files = null)
    {

        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiParsePostAsync
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsync($files = null)
    {
        return $this->pdfWebapiParsePostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiParsePostAsyncWithHttpInfo
     *
     * Parses the provided files using a parser service.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiParsePost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiParsePostRequest($files = null)
    {
        $resourcePath = 'http://localhost:5000/pdf/webapi/parse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRedactPost
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRedactPost($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        list($response) = $this->pdfWebapiRedactPostWithHttpInfo($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);
        return $response;
    }

    /**
     * Operation pdfWebapiRedactPostWithHttpInfo
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRedactPostWithHttpInfo($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRedactPostAsync
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsync($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        return $this->pdfWebapiRedactPostAsyncWithHttpInfo($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRedactPostAsyncWithHttpInfo
     *
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsyncWithHttpInfo($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRedactPost'
     *
     * @param  string[] $files (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRedactPostRequest($files = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/redact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_query !== null) {
            $queryParams['searchQuery'] = ObjectSerializer::toQueryValue($search_query, null);
        }
        // query params
        if ($replace_text !== null) {
            $queryParams['replaceText'] = ObjectSerializer::toQueryValue($replace_text, null);
        }
        // query params
        if ($case_sensitive !== null) {
            $queryParams['caseSensitive'] = ObjectSerializer::toQueryValue($case_sensitive, null);
        }
        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text, null);
        }
        // query params
        if ($comments !== null) {
            $queryParams['comments'] = ObjectSerializer::toQueryValue($comments, null);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveIdPost
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveIdPost($id)
    {
        list($response) = $this->pdfWebapiRemoveIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveIdPostWithHttpInfo
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsync
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsync($id)
    {
        return $this->pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsyncWithHttpInfo
     *
     * Removes all files from processing.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveIdPost'
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiRemoveIdPost'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovePost
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovePost($files = null)
    {
        list($response) = $this->pdfWebapiRemovePostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovePostWithHttpInfo
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovePostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovePostAsync
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsync($files = null)
    {
        return $this->pdfWebapiRemovePostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovePostAsyncWithHttpInfo
     *
     * Removes annotations from the provided documents.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovePost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovePostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPost
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text watermark_text (optional)
     * @param  int $top top (optional)
     * @param  int $left left (optional)
     * @param  int $bottom bottom (optional)
     * @param  int $right right (optional)
     * @param  string[] $files files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  string $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveWatermarkPost($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostWithHttpInfo
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  string $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsync
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  string $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsync($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        return $this->pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo
     *
     * Removes a watermark from the provided files.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  string $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $is_all_pages, $watermark_type, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveWatermarkPost'
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  string $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveWatermarkPostRequest($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/remove-watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_all_pages !== null) {
            $queryParams['isAllPages'] = ObjectSerializer::toQueryValue($is_all_pages, null);
        }
        // query params
        if ($watermark_type !== null) {
            $queryParams['watermarkType'] = ObjectSerializer::toQueryValue($watermark_type, null);
        }
        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }


        // form params
        if ($watermark_text !== null) {
            $formParams['watermarkText'] = ObjectSerializer::toFormValue($watermark_text);
        }
        // form params
        if ($top !== null) {
            $formParams['top'] = ObjectSerializer::toFormValue($top);
        }
        // form params
        if ($left !== null) {
            $formParams['left'] = ObjectSerializer::toFormValue($left);
        }
        // form params
        if ($bottom !== null) {
            $formParams['bottom'] = ObjectSerializer::toFormValue($bottom);
        }
        // form params
        if ($right !== null) {
            $formParams['right'] = ObjectSerializer::toFormValue($right);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovepagesPost
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovepagesPost($files = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemovepagesPostWithHttpInfo($files, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovepagesPostWithHttpInfo
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovepagesPostWithHttpInfo($files = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsync
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsync($files = null, $remove_range = null)
    {
        return $this->pdfWebapiRemovepagesPostAsyncWithHttpInfo($files, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsyncWithHttpInfo
     *
     * Removes specified pages from the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsyncWithHttpInfo($files = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovepagesPost'
     *
     * @param  string[] $files (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovepagesPostRequest($files = null, $remove_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/removepages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {

            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

//                    foreach ($formParams as $formParamName => $formParamValue) {
//                        print_r($formParamValue);
//
//                        $multipartContents[] = [
//                            'name' => ,
//                            'contents' => $formParamValue
//                        ];
//                    }


                    $httpBody = new MultipartStream($multipartContents);

            }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);


        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRepairPost
     *
     * Repairs the provided files.
     *
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRepairPost($files = null)
    {
        list($response) = $this->pdfWebapiRepairPostWithHttpInfo($files);
        return $response;
    }

    /**
     * Operation pdfWebapiRepairPostWithHttpInfo
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRepairPostWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRepairPostAsync
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsync($files = null)
    {
        return $this->pdfWebapiRepairPostAsyncWithHttpInfo($files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRepairPostAsyncWithHttpInfo
     *
     * Repairs the provided files.
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsyncWithHttpInfo($files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRepairPost'
     *
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRepairPostRequest($files = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/repair';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiResizePost
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $resize_type The type of resizing to apply. (optional)
     * @param  string $preset_type The type of preset size to use for resizing. (optional)
     * @param  string $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  string $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiResizePost($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        list($response) = $this->pdfWebapiResizePostWithHttpInfo($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);
        return $response;
    }

    /**
     * Operation pdfWebapiResizePostWithHttpInfo
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $resize_type The type of resizing to apply. (optional)
     * @param  string $preset_type The type of preset size to use for resizing. (optional)
     * @param  string $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  string $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiResizePostWithHttpInfo($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiResizePostAsync
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $resize_type The type of resizing to apply. (optional)
     * @param  string $preset_type The type of preset size to use for resizing. (optional)
     * @param  string $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  string $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsync($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        return $this->pdfWebapiResizePostAsyncWithHttpInfo($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiResizePostAsyncWithHttpInfo
     *
     * Resizes the provided files to the specified dimensions or using a preset size.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $resize_type The type of resizing to apply. (optional)
     * @param  string $preset_type The type of preset size to use for resizing. (optional)
     * @param  string $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  string $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiResizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  int $resize_type The type of resizing to apply. (optional)
     * @param  string $preset_type The type of preset size to use for resizing. (optional)
     * @param  string $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  string $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiResizePostRequest($files = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/resize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($resize_type !== null) {
            $queryParams['resizeType'] = ObjectSerializer::toQueryValue($resize_type, 'int32');
        }
        // query params
        if ($preset_type !== null) {
            $queryParams['presetType'] = ObjectSerializer::toQueryValue($preset_type, null);
        }
        // query params
        if ($preset_size !== null) {
            $queryParams['presetSize'] = ObjectSerializer::toQueryValue($preset_size, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($percentage !== null) {
            $queryParams['percentage'] = ObjectSerializer::toQueryValue($percentage, 'int32');
        }
        // query params
        if ($use_proportions !== null) {
            $queryParams['useProportions'] = ObjectSerializer::toQueryValue($use_proportions, null);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRotatePost
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files files (optional)
     * @param  int $angle The angle by which to rotate the files. (optional)
     * @param  string $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRotatePost($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        list($response) = $this->pdfWebapiRotatePostWithHttpInfo($files, $angle, $rotate_type, $page_num);
        return $response;
    }

    /**
     * Operation pdfWebapiRotatePostWithHttpInfo
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  int $angle The angle by which to rotate the files. (optional)
     * @param  string $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRotatePostWithHttpInfo($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $angle, $rotate_type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRotatePostAsync
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  int $angle The angle by which to rotate the files. (optional)
     * @param  string $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsync($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        return $this->pdfWebapiRotatePostAsyncWithHttpInfo($files, $angle, $rotate_type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRotatePostAsyncWithHttpInfo
     *
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     *
     * @param  string[] $files (optional)
     * @param  int $angle The angle by which to rotate the files. (optional)
     * @param  string $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsyncWithHttpInfo($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $angle, $rotate_type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRotatePost'
     *
     * @param  string[] $files (optional)
     * @param  int $angle The angle by which to rotate the files. (optional)
     * @param  string $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRotatePostRequest($files = null, $angle = null, $rotate_type = null, $page_num = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/rotate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($angle !== null) {
            $queryParams['angle'] = ObjectSerializer::toQueryValue($angle, 'int32');
        }
        // query params
        if ($rotate_type !== null) {
            $queryParams['rotateType'] = ObjectSerializer::toQueryValue($rotate_type, null);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchPost
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchPost($files = null, $query = null)
    {
        list($response) = $this->pdfWebapiSearchPostWithHttpInfo($files, $query);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchPostWithHttpInfo
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchPostWithHttpInfo($files = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchPostAsync
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsync($files = null, $query = null)
    {
        return $this->pdfWebapiSearchPostAsyncWithHttpInfo($files, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchPostAsyncWithHttpInfo
     *
     * Searches the provided files for the specified query and makr found text with yellow background.
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsyncWithHttpInfo($files = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchPost'
     *
     * @param  string[] $files (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchPostRequest($files = null, $query = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchablePost
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchablePost($files = null, $lang = null)
    {
        list($response) = $this->pdfWebapiSearchablePostWithHttpInfo($files, $lang);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchablePostWithHttpInfo
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchablePostWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchablePostAsync
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsync($files = null, $lang = null)
    {
        return $this->pdfWebapiSearchablePostAsyncWithHttpInfo($files, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchablePostAsyncWithHttpInfo
     *
     * Converts the provided files into a searchable PDF format for the specified language.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsyncWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchablePost'
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchablePostRequest($files = null, $lang = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/searchable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSignaturePost
     *
     * Adds a signature to the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSignaturePost($files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        list($response) = $this->pdfWebapiSignaturePostWithHttpInfo($files, $input_type, $output_type, $signature_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSignaturePostWithHttpInfo
     *
     * Adds a signature to the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSignaturePostWithHttpInfo($files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($files, $input_type, $output_type, $signature_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSignaturePostAsync
     *
     * Adds a signature to the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsync($files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        return $this->pdfWebapiSignaturePostAsyncWithHttpInfo($files, $input_type, $output_type, $signature_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSignaturePostAsyncWithHttpInfo
     *
     * Adds a signature to the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsyncWithHttpInfo($files = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($files, $input_type, $output_type, $signature_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSignaturePost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  string $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSignaturePostRequest($files = null, $input_type = null, $output_type = null, $signature_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/Signature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($signature_type !== null) {
            $queryParams['signatureType'] = ObjectSerializer::toQueryValue($signature_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitdocPost
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitdocPost($files = null, $split_type = null, $pars = null)
    {
        list($response) = $this->pdfWebapiSplitdocPostWithHttpInfo($files, $split_type, $pars);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitdocPostWithHttpInfo
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitdocPostWithHttpInfo($files = null, $split_type = null, $pars = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $split_type, $pars);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitdocPostAsync
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsync($files = null, $split_type = null, $pars = null)
    {
        return $this->pdfWebapiSplitdocPostAsyncWithHttpInfo($files, $split_type, $pars)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitdocPostAsyncWithHttpInfo
     *
     * Splits the provided documents based on the specified split type and page rage to spit.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsyncWithHttpInfo($files = null, $split_type = null, $pars = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $split_type, $pars);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitdocPost'
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  string $pars Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitdocPostRequest($files = null, $split_type = null, $pars = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/splitdoc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, 'int32');
        }
        // query params
        if ($pars !== null) {
            $queryParams['pars'] = ObjectSerializer::toQueryValue($pars, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitimagePost
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitimagePost($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiSplitimagePostWithHttpInfo($files, $split_type, $vertical, $horizontal, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitimagePostWithHttpInfo
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitimagePostWithHttpInfo($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $split_type, $vertical, $horizontal, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitimagePostAsync
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsync($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        return $this->pdfWebapiSplitimagePostAsyncWithHttpInfo($files, $split_type, $vertical, $horizontal, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitimagePostAsyncWithHttpInfo
     *
     * Splits the provided images into smaller parts based on the specified parameters.
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsyncWithHttpInfo($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $split_type, $vertical, $horizontal, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitimagePost'
     *
     * @param  string[] $files (optional)
     * @param  int $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitimagePostRequest($files = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/splitimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, 'int32');
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiStatusIdPost
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiStatusIdPost($id)
    {
        list($response) = $this->pdfWebapiStatusIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiStatusIdPostWithHttpInfo
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiStatusIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiStatusIdPostAsync
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsync($id)
    {
        return $this->pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiStatusIdPostAsyncWithHttpInfo
     *
     * Retrieves the status of a processing.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiStatusIdPost'
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiStatusIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiStatusIdPost'
            );
        }

        $resourcePath = 'http://localhost:5000/pdf/webapi/status/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),//$this->config->getHost() . 
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiUnlockPost
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiUnlockPost($files = null, $passw = null)
    {
        list($response) = $this->pdfWebapiUnlockPostWithHttpInfo($files, $passw);
        return $response;
    }

    /**
     * Operation pdfWebapiUnlockPostWithHttpInfo
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiUnlockPostWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($files, $passw);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiUnlockPostAsync
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsync($files = null, $passw = null)
    {
        return $this->pdfWebapiUnlockPostAsyncWithHttpInfo($files, $passw)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiUnlockPostAsyncWithHttpInfo
     *
     * Attempts to unlock a document with an password and associated files.
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsyncWithHttpInfo($files = null, $passw = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($files, $passw);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiUnlockPost'
     *
     * @param  string[] $files (optional)
     * @param  string $passw The password used in locked document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiUnlockPostRequest($files = null, $passw = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiVerifyEsignPost
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiVerifyEsignPost($files = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiVerifyEsignPostWithHttpInfo($files, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiVerifyEsignPostWithHttpInfo
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiVerifyEsignPostWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            }
            if ($returnType === 'string[]'){
                $content = $responseBody; //stream goes to serializer
                $decodeContent = json_decode($content, true);
                if (is_array($decodeContent)){
                    $processContent = [];
                    foreach ($decodeContent as $file){
                        if (is_string($file) && file_exists($file)){
                            $processContent[] = fopen($file, 'r');
                        }
                    }
                    $content = $processContent;
                }
                else {
                    $content = $decodeContent;
                }
            }
            else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsync
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsync($files = null, $input_type = null)
    {
        return $this->pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsyncWithHttpInfo
     *
     * Verifies the electronic signature of the provided files.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiVerifyEsignPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiVerifyEsignPostRequest($files = null, $input_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/verify_esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request = new Request(
            'POST',
            $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );

        return  $request;
    }

    /**
     * Operation pdfWebapiWatermarkPost
     *
     * Adds a watermark to the provided files.
     *
     * @param  bool $is_text is_text (optional)
     * @param  string $text text (optional)
     * @param  string $name2 name2 (optional)
     * @param  int $size size (optional)
     * @param  bool $bold bold (optional)
     * @param  bool $italic italic (optional)
     * @param  bool $underlined underlined (optional)
     * @param  string $color color (optional)
     * @param  string $content_type content_type (optional)
     * @param  string $content_disposition content_disposition (optional)
     * @param  map[string,string[]] $headers headers (optional)
     * @param  int $length length (optional)
     * @param  string $name name (optional)
     * @param  string $file_name file_name (optional)
     * @param  bool $is_background is_background (optional)
     * @param  int $rotation rotation (optional)
     * @param  float $transparency transparency (optional)
     * @param  bool $layer layer (optional)
     * @param  int $page_from page_from (optional)
     * @param  int $page_to page_to (optional)
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWatermarkPost($is_text = null, $text = null, $name2 = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $content_type = null, $content_disposition = null, $headers = null, $length = null, $name = null, $file_name = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null, $files = null, $input_type = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiWatermarkPostWithHttpInfo($is_text, $text, $name2, $size, $bold, $italic, $underlined, $color, $content_type, $content_disposition, $headers, $length, $name, $file_name, $is_background, $rotation, $transparency, $layer, $page_from, $page_to, $files, $input_type, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiWatermarkPostWithHttpInfo
     *
     * Adds a watermark to the provided files.
     *
     * @param  bool $is_text (optional)
     * @param  string $text (optional)
     * @param  string $name2 (optional)
     * @param  int $size (optional)
     * @param  bool $bold (optional)
     * @param  bool $italic (optional)
     * @param  bool $underlined (optional)
     * @param  string $color (optional)
     * @param  string $content_type (optional)
     * @param  string $content_disposition (optional)
     * @param  map[string,string[]] $headers (optional)
     * @param  int $length (optional)
     * @param  string $name (optional)
     * @param  string $file_name (optional)
     * @param  bool $is_background (optional)
     * @param  int $rotation (optional)
     * @param  float $transparency (optional)
     * @param  bool $layer (optional)
     * @param  int $page_from (optional)
     * @param  int $page_to (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWatermarkPostWithHttpInfo($is_text = null, $text = null, $name2 = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $content_type = null, $content_disposition = null, $headers = null, $length = null, $name = null, $file_name = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null, $files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($is_text, $text, $name2, $size, $bold, $italic, $underlined, $color, $content_type, $content_disposition, $headers, $length, $name, $file_name, $is_background, $rotation, $transparency, $layer, $page_from, $page_to, $files, $input_type, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWatermarkPostAsync
     *
     * Adds a watermark to the provided files.
     *
     * @param  bool $is_text (optional)
     * @param  string $text (optional)
     * @param  string $name2 (optional)
     * @param  int $size (optional)
     * @param  bool $bold (optional)
     * @param  bool $italic (optional)
     * @param  bool $underlined (optional)
     * @param  string $color (optional)
     * @param  string $content_type (optional)
     * @param  string $content_disposition (optional)
     * @param  map[string,string[]] $headers (optional)
     * @param  int $length (optional)
     * @param  string $name (optional)
     * @param  string $file_name (optional)
     * @param  bool $is_background (optional)
     * @param  int $rotation (optional)
     * @param  float $transparency (optional)
     * @param  bool $layer (optional)
     * @param  int $page_from (optional)
     * @param  int $page_to (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsync($is_text = null, $text = null, $name2 = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $content_type = null, $content_disposition = null, $headers = null, $length = null, $name = null, $file_name = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null, $files = null, $input_type = null, $output_type = null)
    {
        return $this->pdfWebapiWatermarkPostAsyncWithHttpInfo($is_text, $text, $name2, $size, $bold, $italic, $underlined, $color, $content_type, $content_disposition, $headers, $length, $name, $file_name, $is_background, $rotation, $transparency, $layer, $page_from, $page_to, $files, $input_type, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWatermarkPostAsyncWithHttpInfo
     *
     * Adds a watermark to the provided files.
     *
     * @param  bool $is_text (optional)
     * @param  string $text (optional)
     * @param  string $name2 (optional)
     * @param  int $size (optional)
     * @param  bool $bold (optional)
     * @param  bool $italic (optional)
     * @param  bool $underlined (optional)
     * @param  string $color (optional)
     * @param  string $content_type (optional)
     * @param  string $content_disposition (optional)
     * @param  map[string,string[]] $headers (optional)
     * @param  int $length (optional)
     * @param  string $name (optional)
     * @param  string $file_name (optional)
     * @param  bool $is_background (optional)
     * @param  int $rotation (optional)
     * @param  float $transparency (optional)
     * @param  bool $layer (optional)
     * @param  int $page_from (optional)
     * @param  int $page_to (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsyncWithHttpInfo($is_text = null, $text = null, $name2 = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $content_type = null, $content_disposition = null, $headers = null, $length = null, $name = null, $file_name = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null, $files = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($is_text, $text, $name2, $size, $bold, $italic, $underlined, $color, $content_type, $content_disposition, $headers, $length, $name, $file_name, $is_background, $rotation, $transparency, $layer, $page_from, $page_to, $files, $input_type, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWatermarkPost'
     *
     * @param  bool $is_text (optional)
     * @param  string $text (optional)
     * @param  string $name2 (optional)
     * @param  int $size (optional)
     * @param  bool $bold (optional)
     * @param  bool $italic (optional)
     * @param  bool $underlined (optional)
     * @param  string $color (optional)
     * @param  string $content_type (optional)
     * @param  string $content_disposition (optional)
     * @param  map[string,string[]] $headers (optional)
     * @param  int $length (optional)
     * @param  string $name (optional)
     * @param  string $file_name (optional)
     * @param  bool $is_background (optional)
     * @param  int $rotation (optional)
     * @param  float $transparency (optional)
     * @param  bool $layer (optional)
     * @param  int $page_from (optional)
     * @param  int $page_to (optional)
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWatermarkPostRequest($is_text = null, $text = null, $name2 = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $content_type = null, $content_disposition = null, $headers = null, $length = null, $name = null, $file_name = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null, $files = null, $input_type = null, $output_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($is_text !== null) {
            $formParams['isText'] = ObjectSerializer::toFormValue($is_text);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = ObjectSerializer::toFormValue($text);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($size !== null) {
            $formParams['size'] = ObjectSerializer::toFormValue($size);
        }
        // form params
        if ($bold !== null) {
            $formParams['bold'] = ObjectSerializer::toFormValue($bold);
        }
        // form params
        if ($italic !== null) {
            $formParams['italic'] = ObjectSerializer::toFormValue($italic);
        }
        // form params
        if ($underlined !== null) {
            $formParams['underlined'] = ObjectSerializer::toFormValue($underlined);
        }
        // form params
        if ($color !== null) {
            $formParams['color'] = ObjectSerializer::toFormValue($color);
        }
        // form params
        if ($content_type !== null) {
            $formParams['ContentType'] = ObjectSerializer::toFormValue($content_type);
        }
        // form params
        if ($content_disposition !== null) {
            $formParams['ContentDisposition'] = ObjectSerializer::toFormValue($content_disposition);
        }
        // form params
        if ($headers !== null) {
            $formParams['Headers'] = ObjectSerializer::toFormValue($headers);
        }
        // form params
        if ($length !== null) {
            $formParams['Length'] = ObjectSerializer::toFormValue($length);
        }
        // form params
        if ($name !== null) {
            $formParams['Name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($file_name !== null) {
            $formParams['FileName'] = ObjectSerializer::toFormValue($file_name);
        }
        // form params
        if ($is_background !== null) {
            $formParams['isBackground'] = ObjectSerializer::toFormValue($is_background);
        }
        // form params
        if ($rotation !== null) {
            $formParams['rotation'] = ObjectSerializer::toFormValue($rotation);
        }
        // form params
        if ($transparency !== null) {
            $formParams['transparency'] = ObjectSerializer::toFormValue($transparency);
        }
        // form params
        if ($layer !== null) {
            $formParams['layer'] = ObjectSerializer::toFormValue($layer);
        }
        // form params
        if ($page_from !== null) {
            $formParams['pageFrom'] = ObjectSerializer::toFormValue($page_from);
        }
        // form params
        if ($page_to !== null) {
            $formParams['pageTo'] = ObjectSerializer::toFormValue($page_to);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiWordCounterPost
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWordCounterPost($files = null, $page_range = null)
    {
        list($response) = $this->pdfWebapiWordCounterPostWithHttpInfo($files, $page_range);
        return $response;
    }

    /**
     * Operation pdfWebapiWordCounterPostWithHttpInfo
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWordCounterPostWithHttpInfo($files = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordCounterPostRequest($files, $page_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWordCounterPostAsync
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordCounterPostAsync($files = null, $page_range = null)
    {
        return $this->pdfWebapiWordCounterPostAsyncWithHttpInfo($files, $page_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWordCounterPostAsyncWithHttpInfo
     *
     * Counts the words in the provided files within the specified page range.
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordCounterPostAsyncWithHttpInfo($files = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordCounterPostRequest($files, $page_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWordCounterPost'
     *
     * @param  string[] $files (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWordCounterPostRequest($files = null, $page_range = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/WordCounter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_range !== null) {
            $queryParams['pageRange'] = ObjectSerializer::toQueryValue($page_range, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiXfaconvertPost
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiXfaconvertPost($files = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiXfaconvertPostWithHttpInfo($files, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiXfaconvertPostWithHttpInfo
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiXfaconvertPostWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsync
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsync($files = null, $input_type = null)
    {
        return $this->pdfWebapiXfaconvertPostAsyncWithHttpInfo($files, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsyncWithHttpInfo
     *
     * Converts the provided documents from XFA format to a different format.
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsyncWithHttpInfo($files = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiXfaconvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiXfaconvertPostRequest($files = null, $input_type = null)
    {

        $resourcePath = 'http://localhost:5000/pdf/webapi/xfaconvert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {

                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        // Проверяем существует ли файл и является ли он доступным для чтения
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');

                            
                            $multipartContents[] = [
                                'name' => 'files[]', 
                                'contents' => new Stream($fileResource), 
                                'filename' => basename($file), 
                                'headers' => [
                                    'Content-Type' => $contentType, 
                                    'Content-Length' => filesize($file), 
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
