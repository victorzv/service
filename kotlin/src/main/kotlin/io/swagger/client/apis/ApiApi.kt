/**
 * Aspose.Pdf RestApi
 * Demo 1
 *
 * OpenAPI spec version: v1
 * Contact: Evgeny.Pirogov@aspose.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.FileResponse

import io.swagger.client.infrastructure.*
import okhttp3.Response

class ApiApi(basePath: kotlin.String = "/") : ApiClient(basePath) {


    /**
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     * This endpoint is used to add page numbers to the provided files with the specified alignment, starting number, and format.  If the addition is started, the response will contain a success status and an optional message.  If the addition fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param vAlignment The vertical alignment of the page numbers. (optional)
     * @param hAlignment The horizontal alignment of the page numbers. (optional)
     * @param startingNumber The starting number for the page numbers. (optional)
     * @param sNumber The number of the first page to start numbering from. (optional)
     * @param fNumber The number of the last page to end numbering at. (optional)
     * @param margin The margin around the page numbers. (optional)
     * @param fontSize The font size of the page numbers. (optional)
     * @param format The format of the page numbers. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiAddnumberPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, vAlignment: kotlin.String? = null, hAlignment: kotlin.String? = null, startingNumber: kotlin.Int? = null, sNumber: kotlin.Int? = null, fNumber: kotlin.Int? = null, margin: kotlin.Int? = null, fontSize: kotlin.Int? = null, format: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (vAlignment != null) {
                put("vAlignment", listOf(vAlignment.toString()))
            }
            if (hAlignment != null) {
                put("hAlignment", listOf(hAlignment.toString()))
            }
            if (startingNumber != null) {
                put("startingNumber", listOf(startingNumber.toString()))
            }
            if (sNumber != null) {
                put("sNumber", listOf(sNumber.toString()))
            }
            if (fNumber != null) {
                put("fNumber", listOf(fNumber.toString()))
            }
            if (margin != null) {
                put("margin", listOf(margin.toString()))
            }
            if (fontSize != null) {
                put("fontSize", listOf(fontSize.toString()))
            }
            if (format != null) {
                put("format", listOf(format.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/addnumber", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return response
//        return when (response.responseType) {
//            ResponseType.Success -> (response as Success<*>).data as FileResponse
//            ResponseType.Informational -> TODO()
//            ResponseType.Redirection -> TODO()
//            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
//            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
//        }
    }
    /**
     * Performs a binary comparison on the provided files.
     * This endpoint is used to perform a binary comparison on the provided files.  If the comparison is started, the response will contain a success status and an optional message.  If the comparison fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiBinaryComparisonPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/BinaryComparison", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Generates a PDF document based on the provided files and question.
     * This endpoint is used to generate a PDF document based on the provided files and question.  If the generation is started, the response will contain a success status and an optional message.  If the generation fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param mode The mode of operation for the PDF generation. (optional)
     * @param question The question to be included in the PDF. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiChatpdfPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, mode: kotlin.Int? = null, question: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (mode != null) {
                put("mode", listOf(mode.toString()))
            }
            if (question != null) {
                put("question", listOf(question.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/chatpdf", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Compare provided files and create document with marked changes.
     * This endpoint is used to compare the provided files.  If the comparison is started, the response will contain a success status and an optional message.  If the comparison fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiComparisonPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): Response/*FileResponse*/ {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/Comparison", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return response
//        return when (response.responseType) {
//            ResponseType.Success -> (response as Success<*>).data as FileResponse
//            ResponseType.Informational -> TODO()
//            ResponseType.Redirection -> TODO()
//            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error".plus(response.body))
//            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
//        }
    }
    /**
     * Compresses the provided files using the specified compression level.
     * This endpoint is used to compress the provided files using the specified compression level.  If the compression is started, the response will contain a success status and an optional message.  If the compression fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param compressType The level of compression to use. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
     *//*
    fun pdfWebapiCompressPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, compressType: kotlin.Int? = null): FileResponse {

        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")

        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (compressType != null) {
                put("compressType", listOf(compressType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/compress", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Converts the provided files from one format to another, with options for XML conversion and font size adjustment.
     * This endpoint is used to convert the provided files from one format to another.  If the conversion is started, the response will contain a success status and an optional message.  If the conversion fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param xmlType The type of XML conversion to perform, if applicable. (optional)
     * @param xmlTag The XML tag to use for conversion, if applicable. (optional)
     * @param fontSise  (optional)
     * @param isToSingle Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param separator The separator to use when converting, if applicable. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiConvertPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, xmlType: kotlin.Int? = null, xmlTag: kotlin.String? = null, fontSise: kotlin.Int? = null, isToSingle: kotlin.Boolean? = null, separator: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (xmlType != null) {
                put("xmlType", listOf(xmlType.toString()))
            }
            if (xmlTag != null) {
                put("xmlTag", listOf(xmlTag.toString()))
            }
            if (fontSise != null) {
                put("fontSise", listOf(fontSise.toString()))
            }
            if (isToSingle != null) {
                put("isToSingle", listOf(isToSingle.toString()))
            }
            if (separator != null) {
                put("separator", listOf(separator.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/convert", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Converts a web page to the specified output format.
     * This endpoint is used to convert a web page to the specified output format.  If the conversion is started, the response will contain a success status and an optional message.  If the conversion fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param webPage  (optional)
     * @param outputType The desired format for the output file. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiConvertWebpagePost(webPage: kotlin.String? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("webPage" to "$webPage")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/convert-webpage", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Crops the provided files to the specified dimensions.
     * This endpoint is used to crop the provided files to the specified dimensions.  If the cropping is started, the response will contain a success status and an optional message.  If the cropping fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param top The number of pixels to crop from the top. (optional)
     * @param right The number of pixels to crop from the right. (optional)
     * @param bottom The number of pixels to crop from the bottom. (optional)
     * @param left The number of pixels to crop from the left. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiCropPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, top: kotlin.Int? = null, right: kotlin.Int? = null, bottom: kotlin.Int? = null, left: kotlin.Int? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (top != null) {
                put("top", listOf(top.toString()))
            }
            if (right != null) {
                put("right", listOf(right.toString()))
            }
            if (bottom != null) {
                put("bottom", listOf(bottom.toString()))
            }
            if (left != null) {
                put("left", listOf(left.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/crop", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Downloads a file.
     * 
     * @param id The id of the processing to download. 
     * @param file The name of the file to download. (optional)
     * @return void
     *
    fun pdfWebapiDownloadIdGet(id: kotlin.String, file: kotlin.String? = null): Unit {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (file != null) {
                put("file", listOf(file.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/pdf/webapi/download/{id}".replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Downloads a file as a stream.
     * 
     * @param id The ID of the processing to download. 
     * @param fileName The name of the file to download. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiDownloadStreamIdPost(id: kotlin.String, fileName: kotlin.String? = null): FileResponse {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (fileName != null) {
                put("fileName", listOf(fileName.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/download-stream/{id}".replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Electronically signs the provided files with the specified certificate and its password.
     * This endpoint is used to electronically sign the provided files with the specified certificate and its password.  If the signing is started, the response will contain a success status and an optional message.  If the signing fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param passw The password to use for electronic signing. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiEsignPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, passw: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (passw != null) {
                put("passw", listOf(passw.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/esign", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Extracts tables from the provided documents and converts them to the specified output format.
     * This endpoint is used to extract tables from the provided files and convert them to the specified output format.  If the extraction is started, the response will contain a success status and an optional message.  If the extraction fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiExtractPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/extract", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Fills a form with the provided files.
     * This endpoint is used to fill a form with the provided files.  If the filling is started, the response will contain a success status and an optional message.  If the filling fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param fileName The name of the file to fill the form with. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiFormFillerPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, fileName: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (fileName != null) {
                put("fileName", listOf(fileName.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/form-filler", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Creates a GIF from the provided images.
     * This endpoint is used to create a GIF from the provided images.  If the creation is started, the response will contain a success status and an optional message.  If the creation fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param keepImagesAsIs Indicates whether the images should be kept as is. (optional)
     * @param resizeToImage The index of the image to resize the other images to. (optional)
     * @param streched  (optional)
     * @param width The width of the GIF. (optional)
     * @param height The height of the GIF. (optional)
     * @param frameTimes The times for each frame in the GIF. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiGifPost(keepImagesAsIs: kotlin.Boolean? = null, resizeToImage: kotlin.Int? = null, streched: kotlin.Boolean? = null, width: kotlin.Int? = null, height: kotlin.Int? = null, frameTimes: kotlin.String? = null): FileResponse {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (keepImagesAsIs != null) {
                put("keepImagesAsIs", listOf(keepImagesAsIs.toString()))
            }
            if (resizeToImage != null) {
                put("resizeToImage", listOf(resizeToImage.toString()))
            }
            if (streched != null) {
                put("streched", listOf(streched.toString()))
            }
            if (width != null) {
                put("width", listOf(width.toString()))
            }
            if (height != null) {
                put("height", listOf(height.toString()))
            }
            if (frameTimes != null) {
                put("frameTimes", listOf(frameTimes.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/gif", query = localVariableQuery
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Hashes the provided files using the specified algorithm.
     * This endpoint is used to hash the provided files using the specified algorithm.  If the hashing is started, the response will contain a success status and an optional message.  If the hashing fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param alg The hashing algorithm to use. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiHashPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, alg: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (alg != null) {
                put("alg", listOf(alg.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/hash", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Locks a document with the provided password and optional files.
     * This endpoint is used to lock a resource with an optional password and associated files.  If the lock is started, the response will contain a success status and processing id.  If the lock fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param passw The password required to lock the resource. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiLockPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, passw: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (passw != null) {
                put("passw", listOf(passw.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/lock", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Merges the provided files into a single document or image, with options for orientation and page size.
     * This endpoint is used to merge the provided files into a single document or image.  If the merge is started, the response will contain a success status and an optional message.  If the merge fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output file. (optional)
     * @param horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param vertical The number of images to merge vertically, if applicable. (optional)
     * @param pageSize The page size for the output file, if applicable. (optional)
     * @param dcIsLandscape Indicates whether the output file should be in landscape orientation. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiMergePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, horizontal: kotlin.Int? = null, vertical: kotlin.Int? = null, pageSize: kotlin.String? = null, dcIsLandscape: kotlin.Boolean? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (horizontal != null) {
                put("horizontal", listOf(horizontal.toString()))
            }
            if (vertical != null) {
                put("vertical", listOf(vertical.toString()))
            }
            if (pageSize != null) {
                put("pageSize", listOf(pageSize.toString()))
            }
            if (dcIsLandscape != null) {
                put("dc_isLandscape", listOf(dcIsLandscape.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/merge", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Performs metadata operations on the provided files.
     * This endpoint is used to perform metadata operations on the provided files.  If the operation is started, the response will contain a success status and an optional message.  If the operation fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param opration  (optional)
     * @param folder The folder where the files are located. (optional)
     * @param name The name of the file to perform the operation on. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiMetadataPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, opration: kotlin.String? = null, folder: kotlin.String? = null, name: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (opration != null) {
                put("opration", listOf(opration.toString()))
            }
            if (folder != null) {
                put("folder", listOf(folder.toString()))
            }
            if (name != null) {
                put("name", listOf(name.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/metadata", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Creates a music video from the provided files.
     * This endpoint is used to create a music video from the provided files.  If the creation is started, the response will contain a success status and an optional message.  If the creation fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param interval The interval between frames in the music video. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiMusicVideoPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, interval: kotlin.Int? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (interval != null) {
                put("interval", listOf(interval.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/music-video", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Organizes the provided documents by removing or moving specified pages.
     * This endpoint is used to organize the provided documents by removing or moving specified pages.  If the organization is started, the response will contain a success status and an optional message.  If the organization fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param remove The pages to remove from the document. (optional)
     * @param move The pages to move within the document. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiOrganizePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, remove: kotlin.String? = null, move: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (remove != null) {
                put("remove", listOf(remove.toString()))
            }
            if (move != null) {
                put("move", listOf(move.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/Organize", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Parses the provided files using a parser service.
     * This endpoint is used to send files to a parser service for processing.  If the parsing is started, the response will contain a success status and an optional message.  If the parsing fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiParsePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/parse", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     * This endpoint is used to redact specified text from the provided files, with options to search case-sensitively and target different parts of the document such as text, comments, and metadata.  If the redaction is started, the response will contain a success status and an optional message.  If the redaction fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param searchQuery The text to search for and redact. (optional)
     * @param replaceText The text to replace the found text with. (optional)
     * @param caseSensitive Indicates whether the search should be case-sensitive. (optional)
     * @param text Indicates whether text should be redacted. (optional)
     * @param comments Indicates whether comments should be redacted. (optional)
     * @param metadata Indicates whether metadata should be redacted. (optional)
     * @return FileResponse
     *
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRedactPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, searchQuery: kotlin.String? = null, replaceText: kotlin.String? = null, caseSensitive: kotlin.Boolean? = null, text: kotlin.Boolean? = null, comments: kotlin.Boolean? = null, metadata: kotlin.Boolean? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (searchQuery != null) {
                put("searchQuery", listOf(searchQuery.toString()))
            }
            if (replaceText != null) {
                put("replaceText", listOf(replaceText.toString()))
            }
            if (caseSensitive != null) {
                put("caseSensitive", listOf(caseSensitive.toString()))
            }
            if (text != null) {
                put("text", listOf(text.toString()))
            }
            if (comments != null) {
                put("comments", listOf(comments.toString()))
            }
            if (metadata != null) {
                put("metadata", listOf(metadata.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/redact", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Removes all files from processing.
     * 
     * @param id The ID of the processing to remove. 
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemoveIdPost(id: kotlin.String): FileResponse {
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove/{id}".replace("{" + "id" + "}", "$id")
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Removes annotations from the provided documents.
     * This endpoint is used to remove annotations from the provided files.  If the removal is started, the response will contain a success status and an optional message.  If the removal fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemovePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Removes a watermark from the provided files.
     * This endpoint is used to remove a watermark from the provided files.  If the removal is started, the response will contain a success status and an optional message.  If the removal fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param watermarkText  (optional)
     * @param top  (optional)
     * @param left  (optional)
     * @param bottom  (optional)
     * @param right  (optional)
     * @param files  (optional)
     * @param isAllPages Indicates whether the watermark should be removed from all pages. (optional)
     * @param watermarkType The type of watermark to remove. (optional)
     * @param removeRange The range of pages to remove the watermark from. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemoveWatermarkPost(watermarkText: kotlin.String? = null, top: kotlin.Int? = null, left: kotlin.Int? = null, bottom: kotlin.Int? = null, right: kotlin.Int? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, isAllPages: kotlin.Boolean? = null, watermarkType: kotlin.String? = null, removeRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("watermarkText" to "$watermarkText", "top" to "$top", "left" to "$left", "bottom" to "$bottom", "right" to "$right", "files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (isAllPages != null) {
                put("isAllPages", listOf(isAllPages.toString()))
            }
            if (watermarkType != null) {
                put("watermarkType", listOf(watermarkType.toString()))
            }
            if (removeRange != null) {
                put("removeRange", listOf(removeRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove-watermark", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Removes specified pages from the provided files.
     * This endpoint is used to remove specified pages from the provided files.  If the removal is started, the response will contain a success status and an optional message.  If the removal fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param removeRange The range of pages to remove from the files. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemovepagesPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, removeRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (removeRange != null) {
                put("removeRange", listOf(removeRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/removepages", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Repairs the provided files.
     * This endpoint is used to repair the provided files.  If the repair is started, the response will contain a success status and an optional message.  If the repair fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRepairPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/repair", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Resizes the provided files to the specified dimensions or using a preset size.
     * This endpoint is used to resize the provided files to the specified dimensions or using a preset size.  If the resizing is started, the response will contain a success status and an optional message.  If the resizing fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param resizeType The type of resizing to apply. (optional)
     * @param presetType The type of preset size to use for resizing. (optional)
     * @param presetSize The preset size to use for resizing. (optional)
     * @param width The desired width of the resized files. (optional)
     * @param height The desired height of the resized files. (optional)
     * @param percentage The percentage to resize the files by. (optional)
     * @param useProportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param pageSize The page size to use for the resized files. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiResizePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, resizeType: kotlin.Int? = null, presetType: kotlin.String? = null, presetSize: kotlin.String? = null, width: kotlin.Int? = null, height: kotlin.Int? = null, percentage: kotlin.Int? = null, useProportions: kotlin.Boolean? = null, pageSize: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (resizeType != null) {
                put("resizeType", listOf(resizeType.toString()))
            }
            if (presetType != null) {
                put("presetType", listOf(presetType.toString()))
            }
            if (presetSize != null) {
                put("presetSize", listOf(presetSize.toString()))
            }
            if (width != null) {
                put("width", listOf(width.toString()))
            }
            if (height != null) {
                put("height", listOf(height.toString()))
            }
            if (percentage != null) {
                put("percentage", listOf(percentage.toString()))
            }
            if (useProportions != null) {
                put("useProportions", listOf(useProportions.toString()))
            }
            if (pageSize != null) {
                put("pageSize", listOf(pageSize.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/resize", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     * This endpoint is used to rotate the provided files by a specified angle.  If the rotation is started, the response will contain a success status and an optional message.  If the rotation fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param angle The angle by which to rotate the files. (optional)
     * @param rotateType The type of rotation to perform. (optional)
     * @param pageNum The page number to rotate, if applicable. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRotatePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, angle: kotlin.Int? = null, rotateType: kotlin.String? = null, pageNum: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (angle != null) {
                put("angle", listOf(angle.toString()))
            }
            if (rotateType != null) {
                put("rotateType", listOf(rotateType.toString()))
            }
            if (pageNum != null) {
                put("pageNum", listOf(pageNum.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/rotate", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Searches the provided files for the specified query and makr found text with yellow background.
     * This endpoint is used to search the provided files for the specified query.  If the search is started, the response will contain a success status and an optional message.  If the search fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param query The text to search for within the files. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSearchPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, query: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (query != null) {
                put("query", listOf(query.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/search", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Converts the provided files into a searchable PDF format for the specified language.
     * This endpoint is used to convert the provided files into a searchable PDF format for the specified language.  If the conversion is started, the response will contain a success status and an optional message.  If the conversion fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param lang The language of the files to be converted. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSearchablePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, lang: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (lang != null) {
                put("lang", listOf(lang.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/searchable", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Adds a signature to the provided files.
     * This endpoint is used to add a signature to the provided files.  If the addition is started, the response will contain a success status and an optional message.  If the addition fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param signatureType The type of signature to add. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSignaturePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, signatureType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (signatureType != null) {
                put("signatureType", listOf(signatureType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/Signature", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Splits the provided documents based on the specified split type and page rage to spit.
     * This endpoint is used to split documents based on the specified split type and page rage.  If the splitting is started, the response will contain a success status and an optional message.  If the splitting fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param splitType The type of splitting to be performed. (optional)
     * @param pars Optional page rage for the splitting operation. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSplitdocPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, splitType: kotlin.Int? = null, pars: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (splitType != null) {
                put("splitType", listOf(splitType.toString()))
            }
            if (pars != null) {
                put("pars", listOf(pars.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/splitdoc", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Splits the provided images into smaller parts based on the specified parameters.
     * This endpoint is used to split images into smaller parts based on the specified parameters.  If the splitting is started, the response will contain a success status and an optional message.  If the splitting fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param splitType The type of splitting to be performed. (optional)
     * @param vertical The number of vertical splits to create. (optional)
     * @param horizontal The number of horizontal splits to create. (optional)
     * @param outputType The desired output format for the split images. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSplitimagePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, splitType: kotlin.Int? = null, vertical: kotlin.Int? = null, horizontal: kotlin.Int? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (splitType != null) {
                put("splitType", listOf(splitType.toString()))
            }
            if (vertical != null) {
                put("vertical", listOf(vertical.toString()))
            }
            if (horizontal != null) {
                put("horizontal", listOf(horizontal.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/splitimage", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Retrieves the status of a processing.
     * 
     * @param id The ID of the processing to check the status of. 
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiStatusIdPost(id: kotlin.String): FileResponse {
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/status/{id}".replace("{" + "id" + "}", "$id")
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Attempts to unlock a document with an password and associated files.
     * This endpoint is used to unlock a resource that was previously locked with a password on associated files.  If the unlock is started, the response will contain a success status and an optional message.  If the unlock fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param passw The password used in locked document. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiUnlockPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, passw: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (passw != null) {
                put("passw", listOf(passw.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/unlock", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Verifies the electronic signature of the provided files.
     * This endpoint is used to verify the electronic signature of the provided files.  If the verification is started, the response will contain a success status and an optional message.  If the verification fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiVerifyEsignPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/verify_esign", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    */
    /**
     * Adds a watermark to the provided files.
     * This endpoint is used to add a watermark to the provided files.  If the addition is started, the response will contain a success status and an optional message.  If the addition fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param isText  (optional)
     * @param text  (optional)
     * @param name2  (optional)
     * @param size  (optional)
     * @param bold  (optional)
     * @param italic  (optional)
     * @param underlined  (optional)
     * @param color  (optional)
     * @param contentType  (optional)
     * @param contentDisposition  (optional)
     * @param headers  (optional)
     * @param length  (optional)
     * @param name  (optional)
     * @param fileName  (optional)
     * @param isBackground  (optional)
     * @param rotation  (optional)
     * @param transparency  (optional)
     * @param layer  (optional)
     * @param pageFrom  (optional)
     * @param pageTo  (optional)
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiWatermarkPost(isText: kotlin.Boolean? = null, text: kotlin.String? = null, name2: kotlin.String? = null, size: kotlin.Int? = null, bold: kotlin.Boolean? = null, italic: kotlin.Boolean? = null, underlined: kotlin.Boolean? = null, color: kotlin.String? = null, contentType: kotlin.String? = null, contentDisposition: kotlin.String? = null, headers: kotlin.collections.Map<kotlin.String, kotlin.Array<kotlin.String>>? = null, length: kotlin.Long? = null, name: kotlin.String? = null, fileName: kotlin.String? = null, isBackground: kotlin.Boolean? = null, rotation: kotlin.Int? = null, transparency: kotlin.Float? = null, layer: kotlin.Boolean? = null, pageFrom: kotlin.Int? = null, pageTo: kotlin.Int? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("isText" to "$isText", "text" to "$text", "name" to "$name", "size" to "$size", "bold" to "$bold", "italic" to "$italic", "underlined" to "$underlined", "color" to "$color", "ContentType" to "$contentType", "ContentDisposition" to "$contentDisposition", "Headers" to "$headers", "Length" to "$length", "Name" to "$name", "FileName" to "$fileName", "isBackground" to "$isBackground", "rotation" to "$rotation", "transparency" to "$transparency", "layer" to "$layer", "pageFrom" to "$pageFrom", "pageTo" to "$pageTo", "files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/watermark", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Counts the words in the provided files within the specified page range.
     * This endpoint is used to count the words in the provided files within the specified page range.  If the counting is started, the response will contain a success status and the word count.  If the counting fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param pageRange The range of pages to count words in. (optional)
     * @return FileResponse
     */
    /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiWordCounterPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, pageRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (pageRange != null) {
                put("pageRange", listOf(pageRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/WordCounter", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
    /**
     * Converts the provided documents from XFA format to a different format.
     * This endpoint is used to convert the provided files from XFA format to a different format.  If the conversion is started, the response will contain a success status and an optional message.  If the conversion fails, the response will contain an error status and a message indicating the reason for the failure.
     * @param files  (optional)
     * @param inputType The format of the input files. (optional)
     * @return FileResponse
     */
   /*
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiXfaconvertPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, inputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/xfaconvert", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }*/
}
